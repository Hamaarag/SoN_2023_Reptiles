---
title: "Data wrangling - reptiles"
author: "Orr Comay"
date: "2024-12-18"
output: html_document
---

## Setup

First, load the required R packages:
```{r}
# Setup----
library(tidyverse)
library(readxl)
library(data.table)
library(glmmTMB) # For generalized linear mixed models
library(gllvm)
library(jtools)
library(sf) # For vector GIS objects
library(raster)
library(interactions) # For interaction plots
library(glmmTMB) # For generalized linear mixed models
library(broom.mixed) # easily extract model coefficients
library(extrafont)
library(Cairo) # Export as vector pdf
library(emmeans) # For pairwise comparison among factor levels
library(DHARMa) # Examining GLMM model fit
library(terra) # for handling raster data
Sys.setlocale("LC_ALL", "Hebrew") # For reading and writing csv files with Hebrew
# knitr::opts_knit$set(root.dir = 'C:/Users/User/OneDrive - Tel-Aviv University/Maarag/State of Nature Report/2023/Reptiles') # Change this to your file path

okabe <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", 'red')
```
Here we include all the data wrangling phase preceding the analysis, originally included in the same script as the analysis itself. This has the advantage of avoiding the loading and processing of heavy GIS files every time we want to run subsequent analyses such as species richness etc. Note that the GIS files are NOT in Github but in HaMaarag Google Drive - see the ReadMe file for links.

```{r Load data}
# setwd('C:/Users/User/OneDrive - Tel-Aviv University/Maarag/State of Nature Report/2023/Reptiles') # Change this to your file path
# Reptile data:
reptiles.raw <- fread('../data/raw/2023-04-19_all_rept_data.csv')
reptiles <- copy(reptiles.raw)
reptiles

# Land use data:
land.use <- rast("../data/GIS/LC_Madad_MigvanB_21v1.tif") # see the ReadMe file to see where this file is
plot(land.use) # seems ok
land.use.legend <- read_excel("../data/GIS/Categories4LC2020.xlsx")

# Settlements data:
settlements <- st_read("../data/GIS/SETL_bental_2021.shp") # To calculate distance to nearest settlement
ggplot() + geom_sf(data = settlements) # seems ok
army.bases <- st_read("../data/GIS/Fenced_15_11.shp") # To calculate distance to nearest army base
ggplot() + geom_sf(data = settlements, color = "lightblue") + geom_sf(data = army.bases, color = "red") # seems ok
```

```{r units}
# setwd('C:/Users/User/OneDrive - Tel-Aviv University/Maarag/State of Nature Report/2023/Reptiles') # Change this to your file path

str(reptiles)
summary(reptiles)

# Unit
reptiles[, sort(unique(unit))] # 5 units
reptiles[is.na(unit), .N] # no missing monitoring units
```

```{r campaigns}
reptiles[, .(year = sort(unique(year))), keyby = .(unit, campaign)] # Loess data includes 2013 - the pilot year with a different protocol, and it should be omitted
reptiles <- reptiles[!(year == 2013 & unit %like% 'Loess')]
reptiles[, .(year = sort(unique(year))), keyby = .(unit, campaign)] # problem solved
```

```{r sites, plot and coordinates}
reptiles[is.na(site)] # no missing sites
reptiles[, sort(unique(site))] # Eshel Nanasi is a typo! Ramat HaShofet capitalization should be consistent
reptiles[is.na(latitude) | is.na(longitude), .N] # 2 records have missing coordinates
reptiles[point_name %in% reptiles[is.na(latitude) | is.na(longitude), point_name]] # These are the sole two records from these plots and so I cannot fill in the missing coordinates
reptiles[, sort(unique(site))] # no apparent repetition in site names
reptiles[is.na(point_name), .N] # 523 missing point names
missing.plot.names <- reptiles.raw[year != 2013 & is.na(point_name)]
setcolorder(missing.plot.names, c('unit', 'campaign', 'year', 'site', 'habitat', 'dunes', 'agriculture', 'settlements', 'subunit',
                                  'date', 'time', 'latitude', 'longitude', 'SciName', 'count_individuals'))
setorder(missing.plot.names, unit, campaign, site, date, time)
missing.plot.names
reptiles[is.na(point_name), .N, keyby = .(unit)] # all in Loess, semi desert and planted forests
reptiles[is.na(point_name), .N, keyby = .(unit, year)] # all missing point names are in 2014-2016
multi_coords_plots <- reptiles[!is.na(point_name), .(no.of.lats = uniqueN(latitude), no.of.lons = uniqueN(longitude)), keyby = .(unit, site, point_name)][
  no.of.lats > 1 | no.of.lons > 1] # 4 point names have more than one set of coordinates
multi_coords_plots
reptiles[point_name %in% multi_coords_plots$point_name & site %in% multi_coords_plots$site,
         .(lat = unique(latitude), lon = unique(longitude)), keyby = .(site, point_name)] # difference amounts to the third digit after the decimal point
reptiles[is.na(point_name), point_name := paste(site, case_when(!is.na(settlements) ~ settlements,
                                                                !is.na(agriculture) ~ agriculture,
                                                                !is.na(habitat) ~ habitat,
                                                                !is.na(dunes) ~ dunes,
                                                                .default = ''),
                                                paste(latitude, longitude, sep = '_'), sep = ' ')] # use the original point name, unless it is missing
reptiles[, sort(unique(point_name))] # Hazerim Loess 2 should be Sayeret Shaked Loess 2
reptiles[point_name %like% 'Hazerim', point_name := 'Sayeret Shaked Loess 2']
reptiles[point_name %like% 'Sayeret Shaked Loess 2', point_name := 'Sayeret Shaked Loess 2']

mean.coords <- reptiles[point_name %in% multi_coords_plots$point_name & site %in% multi_coords_plots$site,
                        .(mean.lat = mean(latitude), mean.lon = mean(longitude)), keyby = .(site, point_name)]
merge(reptiles, mean.coords, by = c('site','point_name'), all.x = T)[!is.na(mean.lat), .(unique(point_name))] # 4 plots have multiple coordinates

reptiles <- merge(reptiles, mean.coords, by = c('site','point_name'), all.x = T) # Add the mean coordinates in cases of multiple coordinates per point name
reptiles[is.na(mean.lat), ':=' (mean.lat = latitude, mean.lon = longitude)] # fill in missing mean coordinates when there is no multiplicity
reptiles[is.na(mean.lat) | is.na(mean.lon)] # same two records with no coordinates

reptiles[, conc_lat_lon := paste(mean.lat, mean.lon, sep = '_')] # now we can use mean coordinates to uniquely identify plots

reptiles[!is.na(point_name), .(no.of.lats = uniqueN(latitude), no.of.lons = uniqueN(longitude)), keyby = .(unit, site, point_name)][no.of.lats > 1 | no.of.lons > 1] # there are 4 plots with multiple coordinates
multi_coords_plots <- reptiles[, .(no.of.lats = uniqueN(mean.lat), no.of.lons = uniqueN(mean.lon)), keyby = point_name][no.of.lats > 1 | no.of.lons > 1] # 12 plot names with multiple coordinates - all of them do not have a site name!
reptiles[point_name %in% multi_coords_plots$point_name, point_name := paste(site, point_name)]
reptiles[, .(no.of.lats = uniqueN(mean.lat), no.of.lons = uniqueN(mean.lon)), keyby = point_name][no.of.lats > 1 | no.of.lons > 1] # now there are no plot with multiple coordinates
reptiles[is.na(point_name)] # now there are no missing point names

reptiles[, sort(unique(point_name))] # 380 point names
no.of.plots <- reptiles[, .(no.of.plots = uniqueN(point_name)), keyby = .(unit, year, site)]
no.of.plots

reptiles[, .(no.of.plots = uniqueN(point_name))] # 380 plots overall
reptiles[, .(no.of.plots = uniqueN(point_name)), keyby = .(unit, subunit, year)] # sampling effort vary considerably per campaign in some units
```

```{r Dates}
reptiles[, sort(unique(date))] # the format is day/month/year
reptiles[, Date := as.Date(date, format = '%d/%m/%Y')]
reptiles[, sort(unique(Date))] # now this makes sense!
reptiles[!is.na(point_name), .(no.of.dates = uniqueN(Date)), keyby = .(unit, campaign, year, site, point_name)][no.of.dates > 1] # T0 coastal plain dunes have two dates
reptiles[point_name %in% reptiles[, .(no.of.dates = uniqueN(Date)), keyby = .(unit, campaign, year, site, point_name)][no.of.dates > 1, point_name] & site %in% reptiles[, .(no.of.dates = uniqueN(Date)), keyby = .(unit, campaign, year, site, point_name)][no.of.dates > 1, site] & campaign %in% c("T0", "T1") & !is.na(point_name),
         unique(Date), keyby = .(unit, site, point_name, campaign)]
reptiles[unit %like% 'Coast' & campaign == 'T0', .(Date = unique(Date)), keyby = .(site, point_name)] # These dates are consecutive
reptiles[, Date := min(Date), keyby = .(unit, campaign, point_name)] # 

bla <- copy(reptiles) # Back up before changing dates
bla[, Date := min(Date), keyby =  .(unit, campaign, point_name)] # each survey's date will arbitrary gain its earliest date
bla[, sort(unique(Date))] # make sure the dates make sense
bla[, .(no.of.dates = uniqueN(Date)), keyby = .(unit, campaign, year, site, point_name, point_name)][no.of.dates > 1] # now there is only one date per survey
reptiles <- copy(bla) # return to the original data name
rm(bla) # clean up
```

```{r time}
setorder(reptiles, unit, campaign, site, point_name, time)
reptiles[, sort(unique(time))]

# Time of day
reptiles$time <- as.character(reptiles$time)
class(reptiles$time) # character 
reptiles[is.na(time)] # No missing observation times
reptiles[, .(no.of.times = uniqueN(time)), keyby = .(unit, campaign, site, point_name)][no.of.times > 1] # There are often multiple times per survey ID - we should take the earliest one
reptiles[is.na(as.ITime(time)) & !is.na(time)] # this conversion will produce no NAs
bla <- copy(reptiles)
bla[, ITime := as.ITime(time, tz = 'Asia/Jerusalem')]
class(bla$ITime) # Should be ITime
bla[, .(time = unique(time)), keyby = .(ITime)] # this seems ok
bla[, start_Time := min(ITime), keyby = .(unit, campaign, Date, point_name)] # Take the earliest time per survey
bla[, .(no.of.start_times = uniqueN(start_Time)), keyby = .(unit, campaign, site, point_name)][no.of.start_times > 1] # Now there is only one start time per survey
bla[start_Time  > ITime] # sanity check: start time is never before the observation time - makes sense!
bla[is.na(start_Time)]
bla[as.ITime(time) == ITime, .N] # 2752 cases where time is identical to ITime
bla[as.ITime(time) != ITime, .N] # 0 cases where it is not
bla[is.na(ITime)] # no missing times
reptiles <- copy(bla)
rm(bla)
reptiles[, .(ITime2 = as.ITime(ifelse(is.na(ITime), unique(as.ITime(time, tz = 'Asia/Jerusalem')), ITime))), keyby = .(time, ITime)] # seems reasonable
reptiles[is.na(time) & is.na(as.ITime(ifelse(is.na(ITime), unique(as.ITime(time, tz = 'Asia/Jerusalem')), ITime)))] # no missing times
setorder(reptiles, unit, campaign, site, agriculture, settlements, dunes, point_name, start_Time, ITime)
hist(reptiles[, as.numeric(ITime)], breaks = 24) # X axis is meaningless, but other wise this seems ok
quantile(reptiles$ITime) # Times should not be in UTC though

class(reptiles$start_Time) # should be ITime
reptiles[, .(start_ITime = unique(as.ITime(start_Time, tz = 'Asia/Jerusalem'))), keyby = start_Time] # seems ok
reptiles[, start_Time := as.ITime(start_Time, tz = 'Asia/Jerusalem')]
# Express diel pattern as the sine and cosine of the distance in radians from noon
reptiles[, .(unique(as.POSIXct(paste(Date, time, tz = 'Asia/Jerusalem')))), keyby = .(Date, start_Time)] # seems ok
reptiles[, Date.time := as.POSIXct(paste(Date, start_Time, tz = 'Asia/Jerusalem'))] # Create a Date and time object
class(reptiles$Date.time) # should be POSIXct
reptiles[, .(unique(as.POSIXct(paste(Date, '12:00:00', tz = 'Asia/Jerusalem')))), keyby = .(Date, ITime)]
reptiles[, .(dst(Date))][V1 == T] # From some reason day light saving time is not recognized in the Date field
reptiles[, .(dst(Date.time))][V1 == T, .N] # but it is recognized for Date.time
reptiles[, .(dst(Date.time)), keyby = .(Date.time)][V1 == F] # Only November and late March Dates are not in daylight saving time
head(reptiles[, .(Date.time, Date.time - 3600)]) # as the time units are seconds, to revert one hour we need to subtract 3600 units from Date.time
attr(reptiles$Date.time, 'tzone') # Time zone is not set
attr(reptiles$Date.time, 'tzone') <- 'Asia/Jerusalem' # set time zone
reptiles[, ':=' (Date.time = ifelse(dst(Date.time), Date.time - 3600, Date.time),
                 ITime = ifelse(dst(Date.time), as.ITime(as.ITime(time) - 3600), as.ITime(ITime)))]
reptiles[, ':=' (Date.time = as.POSIXct(Date.time), ITime = as.ITime(ITime))]
reptiles[, .(site, dunes, point_name, Date, start_Time, time, Date.time, ITime)] # Note that the Date.time and ITime are often one hour before the reported time, because it was set to non-daylight saving time 
```

```{r missing & excessive plots}
study.design <- as.data.table(read_excel('../Analysis/Study design.xlsx')) # Import the study design - how many plots per site etc.
surveyed.plots <- reptiles[, .(no.of.surveyed.plots = uniqueN(point_name)), keyby = .(campaign, unit, subunit, site, settlements, agriculture, dunes, habitat)]
surveyed.plots
surveyed.planned.plots <- merge(study.design, surveyed.plots, by = c('unit', 'subunit', 'site', 'settlements', 'agriculture', 'dunes', 'habitat'), all = T)

surveyed.planned.plots[is.na(no.of.planned.plots)] # One site, Hatzerim, was surveyed although it does not appear on the protocols
surveyed.planned.plots[is.na(no.of.surveyed.plots)] # No sites have no plots
missing.excessive.plots <- surveyed.planned.plots[no.of.surveyed.plots != no.of.planned.plots, # Find sites where the number of surveyed plots is different from the number of planned plots
                       .(campaign, unit, subunit, site, settlements, dunes, habitat, agriculture, no.of.planned.plots, no.of.surveyed.plots)] 
setorder(missing.excessive.plots, campaign, unit, subunit, site, settlements, dunes, habitat, agriculture)
missing.excessive.plots[, delta.plots := no.of.surveyed.plots - no.of.planned.plots] # negative values mean missing plots and vice versa
missing.excessive.plots
write_excel_csv(missing.excessive.plots, '../Analysis/Missing or excessive reptile plots.csv')

# Add plots with zero observations as per Boaz Shacham's e-mail 7.12.2023:
# I need to fill in all the missing plots and find out whether they were surveyed with no observations (zero observations) or not surveyed in the first place
zero.obs <- as.data.table(read_excel('../Analysis/Missing reptile plots - Boaz comments.xlsx', sheet = 'zero observations'))
str(zero.obs)
zero.obs[!is.na(ITime), .(ITime, as.ITime = as.ITime(as.character(ITime)))] # "as.character" is necessary for a successful conversion
zero.obs[, ':=' (Date = as.Date(Date), ITime = as.ITime(as.character(ITime)), start_Time = as.ITime(as.character(ITime)))]

data.table(reptiles_col = names(reptiles), is.in.zero.obs = names(reptiles) %in% names(zero.obs)) # Find columns in the reptiles data.table that do not occour in the zero.obs data.table
zero.obs[, ':=' (year = year(Date))]
data.table(reptiles_col = names(reptiles), is.in.zero.obs = names(reptiles) %in% names(zero.obs)) # Find columns in the reptiles data.table that do not occour in the zero.obs data.table
setorder(reptiles, unit, year, campaign, settlements, agriculture, dunes, site, Date)
bla <- rbind(reptiles, zero.obs, fill = T) # add missing zero observations

# Coastal Plain Sands, T0  (2014) - only 3 sites instead of 4 (and 27 plots instead of 36)
reptiles[unit == 'Coastal Plain Sands' & campaign == 'T0', .(plots = unique(point_name)), keyby = .(site, dunes, settlements)] # Caesarea is missing
bla[unit == 'Coastal Plain Sands' & campaign == 'T0', .(plots = unique(point_name)), keyby = .(site, dunes, settlements)] # Caesarea is missing

# Coastal Plain Sands, T3 (2019) - only 35 sites instead of 36; no skipped surveys reported in the summary so we assume no reptiles were found
reptiles[unit == 'Coastal Plain Sands' & campaign == 'T3', .(plots = unique(point_name)), keyby = .(site, dunes, settlements)]
# Caesarea is missing one Near semi-shifting plot in T0, but it does not appear in the Fulcrum app as well
# reptiles <- rbind(reptiles, cbind(data.table(unit = 'Coastal Plain Sands', campaign = 'T3', year = 2019, site = 'Caesarea',
#                                             dunes = 'semi-shifting', settlements = 'Near', SciName = NA, count_individuals = 0,
#                                             point_name = 'Caesarea semi-shifting Near - missing plot',
#                                             point_name = 'Caesarea semi-shifting Near - missing plot')), fill = T)

# Loess, T0  (2014) - 24 plots instead of 30
reptiles[unit == 'Loess Covered Areas in the Northern Negev' & campaign == 'T0', .(plots = unique(point_name)), keyby = .(site, habitat)] # Caesarea is missing
bla[unit == 'Loess Covered Areas in the Northern Negev' & campaign == 'T0', .(plots = unique(point_name)), keyby = .(site, habitat, Date)] # now 29 plots

# Loess, T1  (2015) - 28 plots instead of 30
reptiles[unit == 'Loess Covered Areas in the Northern Negev' & campaign == 'T1', .(plots = unique(point_name)), keyby = .(site, habitat)] 
bla[unit == 'Loess Covered Areas in the Northern Negev' & campaign == 'T1', .(plots = unique(point_name)), keyby = .(site, habitat)] # now 30 plots

# Loess, T2  (2017) - 25 plots instead of 30
reptiles[unit == 'Loess Covered Areas in the Northern Negev' & campaign == 'T2', .(plots = unique(point_name)), keyby = .(site, habitat)] 
bla[unit == 'Loess Covered Areas in the Northern Negev' & campaign == 'T2', .(plots = unique(point_name)), keyby = .(site, habitat)] # now 28 plots

# Loess, T3  (2019) - 22 plots instead of 30
reptiles[unit == 'Loess Covered Areas in the Northern Negev' & campaign == 'T3', .(plots = unique(point_name)), keyby = .(site, habitat)]
bla[unit == 'Loess Covered Areas in the Northern Negev' & campaign == 'T3', .(plots = unique(point_name)), keyby = .(site, habitat)] # still 22 plots

# Med-desert transition, T0  (2014) - 29 plots instead of 30
reptiles[unit == 'Mediterranean-Desert Transition Zone' & campaign == 'T0', .(plots = unique(point_name)), keyby = .(site, settlements)] 
bla[unit == 'Mediterranean-Desert Transition Zone' & campaign == 'T0', .(plots = unique(point_name)), keyby = .(site, settlements, Date)] # now 31 plots
bla[campaign == 'T0' & site == 'Lehavim', sort(unique(point_name))] # As per Boaz Shacham's e-mail from 1.2.2024, Lehavim Near1 was cancelled because it did not contain enough stones so it should be omitted from the data
bla[point_name == 'Lehavim Near 1'] # only one record from this plot
bla <- bla[point_name != 'Lehavim Near 1'] # omit it 
# There was also an issue with a plot discovered to be an archaeological site in Lehavim Near in 2014 (T0):
reptiles.raw[site == 'Lehavim' & campaign == 'T0' & settlements == 'Near',
             .(latitude, longitude, settlements, point_name, date, time, SciName, count_individuals, obs_notes)]
# raw data: 4 Near plots, 2 with coordinates but no names (1 from 24/4/2014 and 1 from 26/6/2014) and 2 with names but no coordinates (both from 24/4/2014 - 2 months earlier)
bla[site == 'Lehavim' & campaign == 'T0', .(conc_lat_lon, point_name, Date, time, SciName, count_individuals)]
# According to Boaz Shacham's mail from 31/1/2024, Near 5 was an archaeological site (...and thus should be omitted? Unclear).
# According to the raw data file ('SFAR_2014_06_26c.xlsx'), Near5's observations are from 11:57 and 12:02
bla <- bla[!(site == 'Lehavim' & campaign == 'T0' & time %in% c('11:57:00', '12:02:00'))] # So omit these observations
bla[site == 'Lehavim', .(no.of.campaigns.surveyed = uniqueN(campaign)), keyby = .(point_name, conc_lat_lon, latitude, longitude)] # Lehavim Near 11 has coordinats only in some campaigns
bla[point_name == 'Lehavim Near 11', .(campaign, Date, point_name, ITime, longitude, latitude, conc_lat_lon, SciName, count_individuals)] # conc_lat_lon is missing for T1 (zero count)
bla[point_name == 'Lehavim Near 11', conc_lat_lon := '31.3659832_34.82240395']
bla[conc_lat_lon == '31.36355103_34.82061174', .(campaign, Date, point_name, ITime, longitude, latitude, conc_lat_lon, SciName, count_individuals)] # conc_lat_lon is missing for T1 (zero count)
# Lehavim Near 31.36355103_34.82061174 is actually Lehavim Near 12

# Med-desert transition, T1 (2016)
reptiles.raw[unit == 'Mediterranean-Desert Transition Zone' & campaign == 'T1', .(plots = unique(point_name)), keyby = .(year, site, settlements)] # raw data has no plot names
reptiles[unit == 'Mediterranean-Desert Transition Zone' & campaign == 'T1', .(plots = unique(point_name)), keyby = .(year, site, settlements)] # so we give them names from nearby plots
reptiles[site == 'Mirsham', .(plots = unique(point_name)), keyby = .(conc_lat_lon, year, settlements)] # Note that "Mirsham 81" (which is *Near*) is the same as Mirsham *Far* 31.47465474_34.9201405
reptiles[conc_lat_lon == '31.47465474_34.9201405', ':=' (settlements = 'Near', point_name = 'Mirsham 81')] # So correct this error

# The planted conifer forest is missing 2 sites in T0 (2014), and one site in T1 (2015) and T4 (2021)
reptiles[unit == 'Planted Conifer Forests' & campaign %in% c('T1', 'T4'), .(plots = unique(point_name)),
         keyby = .(campaign, year, subunit,site, Date, start_Time, point_name)]
bla[unit == 'Planted Conifer Forests' & campaign %in% c('T1', 'T4'), .(plots = unique(point_name)),
         keyby = .(campaign, year, subunit, site, Date, start_Time, point_name)]

# The planted conifer forest is missing 7 plots in T2, and 6 plots in T2
reptiles[unit == 'Planted Conifer Forests' & campaign %in% c('T2', 'T3'), .(plots = unique(point_name)),
         keyby = .(campaign, year, subunit, site, point_name)]
bla[unit == 'Planted Conifer Forests' & campaign %in% c('T2', 'T3'), .(plots = unique(point_name)),
         keyby = .(campaign, year, subunit, site, point_name)]

# Missing plots in T1 (2015)
reptiles[unit == 'Planted Conifer Forests' & campaign %in% c('T1'), .(plots = unique(point_name)),
         keyby = .(campaign, year, subunit, site, point_name)]
bla[unit == 'Planted Conifer Forests' & campaign %in% c('T1'), .(plots = unique(point_name)),
         keyby = .(campaign, year, subunit, site, point_name)]

reptiles <- copy(bla) # use the data base with the missing zero observations
rm(bla) # clean up

# Find and export the excessive plots:
excessive_plots <- reptiles[(site == 'Hatzerim') |
                              (site %in% c('Nahal Ashan', 'Sayeret Shaked') & campaign == 'T0') |
                              (campaign == 'T0' & site == 'Lehavim' & settlements == 'Near') |
                              (campaign == 'T1' & site %in% c('Ofer', 'Ramat Hashofet')),
                            .(longitude = unique(longitude), latitude = unique(latitude)),
                            keyby = .(campaign, site, Date, year, habitat, point_name, settlements)]
excessive_plots <-  excessive_plots[!(site == 'Sayeret Shaked' & habitat == 'kkl plantings')]
st_write(st_as_sf(excessive_plots[!is.na(longitude)], coords = c('longitude', 'latitude'), crs = 4326, remove = F),
         '../Analysis/Excessive reptile plots.shp', append = F) # Export the excessive plots as an ESRI shapefile
st_write(st_as_sf(excessive_plots[!is.na(longitude)], coords = c('longitude', 'latitude'), crs = 4326, remove = F),
         '../Analysis/Excessive reptile plots.gpkg', append = F) # Export the excessive plots as a geopackage
reptiles[site == 'Ramat Hashofet', .(unique(point_name)), keyby = .(campaign, Date, latitude, longitude)] 
# only in T1 we have two "Ramat HaShofet" plots which are very, very far away from Ramat HaShofet itself (near Ramot Naftali - might be the cause of confusion?)
reptiles[site == 'Ramat Hashofet' & latitude > 33, .(unique(point_name)), keyby = .(latitude, longitude)] # indeed
reptiles[site == 'Ramat Hashofet' & latitude > 33, ':=' (site = 'Ramot Naftali', subunit = 'Galilee')] # update the data accordingly
reptiles[site == 'Ramot Naftali' & campaign == 'T1']
reptiles[is.na(point_name), .N] # 41 cases of missing point name
reptiles[is.na(point_name) & is.na(conc_lat_lon)] # only one case when both point name and con_lat_lon are missing
reptiles[is.na(point_name) & !is.na(conc_lat_lon), point_name := conc_lat_lon]

# Look for missing plots and sites, that might indicate visits yielding no reptiles at all
campaigns.per.plot <- reptiles[, .(no.of.campaigns.surveyed = uniqueN(campaign)), keyby = .(unit, site, point_name)]
campaigns.per.plot[, total.campaigns.per.unit := max(no.of.campaigns.surveyed), keyby = unit]
campaigns.per.plot[no.of.campaigns.surveyed < total.campaigns.per.unit] # 367 is far too many plots surveyed less than once per campaign

reptiles[, point_name := str_to_title(str_replace(point_name, pattern = '  ', replacement = ' '))]
reptiles[is.na(mean.lat) | is.na(mean.lon)]
reptiles[is.na(mean.lat) | is.na(mean.lon), ':=' (mean.lat = latitude, mean.lon = longitude)]
survey.plots <- reptiles[!is.na(mean.lat) & !is.na(mean.lon),
                                  .(mean.lon = mean(mean.lon), mean.lat = mean(mean.lat), conc_lat_lon = first(conc_lat_lon)),
                         keyby = .(unit, site, subunit, settlements, habitat, dunes, point_name)] %>% unique() %>% st_as_sf(coords = c('mean.lon', 'mean.lat'), crs = 4326, remove = F)
uniqueN(survey.plots$point_name) == nrow(survey.plots) # should be TRUE
# as.data.table(survey.plots)[, .N, keyby = point_name][N > 1] # 22 plots appearing twice in the survey plots
# as.data.table(survey.plots)[point_name %in% as.data.table(survey.plots)[, .N, keyby = point_name][N > 1, point_name]]
```

```{r plot distances}
# Calculate all distances between plots in the same site, to look for multiplications
plot.distances.all <- data.table(plot = '', conc_lat_lon = '', distance_to_plot = '', distance_m = as.numeric(NA), unit = '', site = '') # Create a data.table to be filled by the loop below
plot.distances.all <- plot.distances.all[plot != ''] # Empty the data.table
str(plot.distances.all)
  
for (i in sort(unique(survey.plots$site))) {
  unit <- as.data.table(survey.plots)[site == i, unique(unit)]
  plot.distances <- as.data.table(st_distance(survey.plots[which(survey.plots$site == i),]))
  names(plot.distances) <- as.data.table(survey.plots)[site == i, as.character(point_name)]
  plot.distances[, ':=' (plot = as.data.table(survey.plots)[site == i, as.character(point_name)],
                         conc_lat_lon = as.data.table(survey.plots)[site == i, as.character(conc_lat_lon)])]
 # setcolorder(plot.distances, 'plot')
  plot.distances.melt <- melt.data.table(plot.distances, id.vars = c('plot', 'conc_lat_lon'), variable.name = 'distance_to_plot', value.name = 'distance_m')
  plot.distances.melt[, ':=' (unit = unit, site = i, distance_m = as.numeric(distance_m))]
  plot.distances.all <- rbind(plot.distances.all, plot.distances.melt)
  rm(plot.distances, plot.distances.melt, unit) # clean up
}
plot.distances.all <- unique(plot.distances.all[plot != distance_to_plot]) # Remove self-distances
plot.distances.all <- merge(plot.distances.all, as.data.table(survey.plots)[, .(mean.lat, mean.lon), keyby = .(plot = point_name, subunit, habitat, settlements, dunes)],
                            by = 'plot', all.x = T) # add coordinates
plot.distances.all <- merge(plot.distances.all, as.data.table(survey.plots)[, .(distance_to_plot = point_name, subunit, habitat, settlements, dunes)],
                            by = 'distance_to_plot', all.x = T) # add coordinates
# Plot the distances between plots
setorder(plot.distances.all, distance_m) # sort by distance between plots
plot(plot.distances.all$distance_m) # up to 10 km between plots
plot(plot.distances.all[distance_m < 2000, distance_m]) # zoom in more and more
plot(plot.distances.all[distance_m < 500, distance_m])
plot(plot.distances.all[distance_m < 150, distance_m]) 
plot(plot.distances.all[distance_m < 50, distance_m]) # 3-5 meters seems like a valid cut-off

plot.distances.same.att <- plot.distances.all[(settlements.x == settlements.y) | is.na(settlements.x)]
plot.distances.same.att <- plot.distances.same.att[(habitat.x == habitat.y) | is.na(habitat.x)]
plot.distances.same.att <- plot.distances.same.att[(dunes.x == dunes.y) | is.na(dunes.x)]
plot.distances.same.att <- plot.distances.same.att[(subunit.x == subunit.y) | is.na(subunit.x)]

setorder(plot.distances.same.att, unit, subunit.x, habitat.x, settlements.x, dunes.x, mean.lat) # Order by unit, site and latitude
plot.distances.same.att[distance_m < 10] # No fewer than 434 plots less than 10 meters away from each other
plot.distances.same.att[distance_m < 5] # Same, less than 5 meters away
plot.distances.same.att[distance_m < 2] # only 414 plots less than 2 meters away from each other
names(plot.distances.same.att) <- gsub('.x', '', names(plot.distances.same.att))
plot.distances.same.att[, ':=' (subunit.y = NULL, habitat.y = NULL, settlements.y = NULL, dunes.y = NULL)]
names(plot.distances.same.att)
plot.distances.same.att[, new_plot_id := ifelse(distance_m < 5, distance_to_plot, plot)] # If the distance between plots is less than 5 meters, take the name of the plot to which the distance was measured
plot.distances.same.att[new_plot_id == plot, .N] # 1702 cases
plot.distances.same.att[new_plot_id == distance_to_plot, .N] # 434 cases
plot.distances.same.att
write_excel_csv(plot.distances.same.att, file = '../Analysis/Distances between plots in the same site.csv')
```

```{r plot synonyms}
# Create a table of pairs of plot codes which are synonyms (same attributes, less than 5 meters apart):
setorder(plot.distances.same.att, plot, distance_m, conc_lat_lon) # sort by distance and plot name
plot.synonyms <- plot.distances.same.att[distance_m < 5, .(new_conc_lat_lon = first(conc_lat_lon)),
                                         keyby = .(site, plot)] # use the first (southernmost) plot ID as the ID for the pair
plot.synonyms <- merge(plot.synonyms, plot.distances.same.att[, .(new_plot_id = first(plot)), keyby = .(new_conc_lat_lon = conc_lat_lon)],
      by = c('new_conc_lat_lon'), all.x = T) # add the new plot name per coordinates
plot.synonyms[, .(conc_lat_lon = new_conc_lat_lon, new_plot_id)]
plot.synonyms <- unique(plot.synonyms)
setcolorder(plot.synonyms, c('plot', 'new_conc_lat_lon', 'new_plot_id'))
plot.synonyms

setorder(plot.synonyms, plot, new_plot_id)
# plot.synonyms <- plot.synonyms[(new_plot_id %like% '_' & plot %like% '_') | !new_plot_id %like% '_'] # remove cases where the new plot ID would include the coordinates, except when the alternative is to lose the synonimity altogether

plot.synonyms[, .(no.of.new_plot_ids = uniqueN(new_conc_lat_lon)), keyby = plot][no.of.new_plot_ids != 1] # only one conc_lat_lon per plot now
setorder(plot.synonyms, plot, new_conc_lat_lon)
plot.synonyms[, uniqueN(plot)] # 248 synonimized plots
bla <- plot.distances.same.att[, .(new_plot_id = unique(plot)), keyby = conc_lat_lon] # list all the synonyms per coordinate pair
multi.new.plot.ids <- bla[, .(no.of.new.plot.ids = uniqueN(new_plot_id)), keyby = conc_lat_lon][no.of.new.plot.ids > 1, conc_lat_lon]
bla[conc_lat_lon %in% multi.new.plot.ids, new_plot_id := first(new_plot_id), by = conc_lat_lon]
bla <- unique(bla)
# plot.synonyms <- merge(plot.synonyms, bla, by.x = 'new_conc_lat_lon', by.y = 'conc_lat_lon', all.x = T)
setorder(plot.synonyms, plot, new_plot_id)
plot.synonyms[, new_plot_id := first(new_plot_id), by = plot]
plot.synonyms <- unique(plot.synonyms[, .(plot, new_plot_id)])
plot.synonyms[, .(no.of.new.plot.ids = uniqueN(new_plot_id)), keyby = plot][no.of.new.plot.ids > 1] # should be an empty data.table

reptiles <- merge(reptiles, plot.synonyms[, .(point_name = plot, new_plot_id)], by = 'point_name', all.x = T) # add the new plot ID to the reptiles database
reptiles[, uniqueN(point_name)] # 371 plot codes before renaming
reptiles[!is.na(new_plot_id), point_name := new_plot_id]
reptiles[, uniqueN(point_name)] # now only 289 plot codes
reptiles[is.na(point_name), .N] # no cases of missing point names
reptiles[is.na(point_name) & is.na(conc_lat_lon), ] # no cases when both point name and conc_lat_lon are missing
reptiles[is.na(point_name), point_name := conc_lat_lon]

point_names <- reptiles[, .(point_name = unique(point_name)), keyby = site]
point_names <- merge(point_names, reptiles[!is.na(point_name) & !is.na(mean.lat), .(settlements = unique(settlements), habitat = unique(habitat),
                                                  agriculture = unique(agriculture), dunes = unique(dunes), mean.lat = mean(mean.lat),
                                                  mean.lon = mean(mean.lon)), keyby = 'point_name'], by = 'point_name', all.x = T)

reptiles[, .(uniqueLats = uniqueN(mean.lat)), keyby = point_name][uniqueLats > 1] # few cases of multiple latitude per point name
reptiles[]
```

```{r campaigns}
# campaign
reptiles[is.na(campaign), .N, keyby = .(unit, year)] # all missing campaigns are in 2018  
reptiles[, unique(campaign), keyby = .(unit, year)] # Should be T2
reptiles[is.na(campaign) & year == 2018, campaign := 'T2']
```

```{r units 2}
# unit
reptiles[, sort(unique(unit))]
reptiles[unit == 'Mediterranean Transition Zone', unit := 'Mediterranean-Desert Transition Zone']
```

```{r survey ID}
# survey ID
reptiles[, survey_ID := paste(campaign, point_name, sep = '_')]
reptiles[, .(no.of.dates = uniqueN(date)), keyby = .(unit, campaign, survey_ID)][no.of.dates > 1] # No fewer than 20 surveys have more than one date, all from T0
reptiles[survey_ID %in% reptiles[, .(no.of.dates = uniqueN(date)), keyby = survey_ID][no.of.dates > 1, survey_ID],
         .(unit, campaign, site, survey_ID, date)] # All from T0 (2014) coastal plain dunes
# These cases are all one day apart, luckily. We will arbitrarily take the first date of each
reptiles[, .(Date = min(date)), keyby = survey_ID]
reptiles[, .(no.of.surveys = uniqueN(survey_ID))] # 698 surveys overall
reptiles[count_individuals > 0, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(unit)] # only surveys where at least one reptile was found
reptiles[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(unit)]
reptiles[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(unit, campaign, year)]
reptiles[, sort(unique(settlements)), keyby = unit] # this is only meaningful in the coastal plain and semi desert
reptiles[unit %like% 'Forest', settlements := NA]
reptiles[, sort(unique(habitat))]
reptiles[habitat %like% 'agri', habitat := "bedouin agriculture"]
plot.surveyed <- reptiles[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(unit, campaign, year, site, habitat, dunes, agriculture, settlements)]
plot.surveyed[no.of.surveys != 3]
plot.surveyed
merge(plot.surveyed, data.table(expand.grid(site = reptiles[, unique(site)], campaign = c('T0', 'T1', 'T2', 'T3', 'T4'))),
      by = c('site', 'campaign'), all.x = T)[is.na(no.of.surveys)] # empty data.table -> all sites were surveyed at least once per campaign
write_excel_csv(plot.surveyed, '../Analysis/No. of plots surveyed breakdown 29.1.2024.csv')
```

```{r plots per site-campaign}
# 4 plots in Lehavim in 2014 (should be only 3):
reptiles[site %like% 'Lehavim' & year == 2014, .(Date, ITime, SciName, count_individuals), keyby = .(campaign, settlements, point_name)]
reptiles[point_name == 'Lehavim Near 31.3659832_34.82239692', point_name := 'Lehavim Near 11']

# 4 plots in KKL plantings in Nahal Ashan in 2014 (should be only 3):
reptiles[campaign == 'T0' & site %like% 'Ashan', .(unique(point_name)), keyby = .(Date, habitat)] # 31.2826508607692_34.7486309384615 is the same as 31.28265003_34.74862372
# We use the original excel file from 2014 to correctly assign observations to plots. Nahal Ashan kkl 1 had only one Chalcides ocellatus and nothing else:
reptiles[campaign == 'T0' & site %like% 'Ashan', .(SciName), keyby = .(Date, ITime, point_name, habitat)] 
# Nahal Ashan Kkl Plantings 31.28265003_34.74862372 = Nahal Ashan Kkl Plantings 2; 
# Nahal Ashan Kkl Plantings 31.28684679_34.74364408 = Nahal Ashan Kkl Plantings 1; 
# Nahal Ashan Kkl Plantings 31.29349178_34.74750308 = Nahal Ashan Kkl Plantings 3
reptiles[point_name == 'Nahal Ashan Kkl Plantings 31.28265003_34.74862372', point_name := 'Nahal Ashan Kkl Plantings 2']
reptiles[point_name == 'Nahal Ashan Kkl Plantings 31.28684679_34.74364408', point_name := 'Nahal Ashan Kkl Plantings 1']
reptiles[point_name == 'Nahal Ashan Kkl Plantings 31.29349178_34.74750308', point_name := 'Nahal Ashan Kkl Plantings 3']
reptiles[unit %like% 'Loess' & campaign == 'T0' & site %like% 'Ashan', .(unique(point_name)), keyby = .(Date, habitat)] # now only 3 plots, as expected

# 4 plots in KKL plantings in Nahal Ashan in 2018 (should be only 3):
reptiles[unit %like% 'Loess' & campaign == 'T2' & site %like% 'Ashan', .(total.obs = sum(count_individuals)),
         keyby = .(Date, habitat, point_name)] # Only 3 plots per habitat, as expected, but one plot has zero observations (Nahal Ashan Loess 2) 

# only 2 plots in Aderet in T0 - why?
reptiles[site %like% 'Aderet' & campaign == 'T0', .(point_name, SciName, count_individuals), keyby = .(Date, ITime)] # By comparing to the original data file, we can see that all 3 Aderet plots were surveyed:
# Aderet 31.67145208_34.98801954 = Aderet Kkl 3; Aderet 31.67578059_34.98668299 = Aderet Kkl 2
reptiles[point_name == 'Aderet 31.67145208_34.98801954', point_name := 'Aderet Kkl 3']
reptiles[point_name == 'Aderet 31.67578059_34.98668299', point_name := 'Aderet Kkl 2']

# Only 1 plot in Bat Shlomo in T0 - why?
reptiles[site %like% 'Bat Shlomo' & campaign == 'T0', .(point_name, SciName, count_individuals), keyby = .(Date, ITime)] # By comparing to the original data file, we can see that all 3 Bat Shlomo plots were surveyed:
reptiles[point_name == 'Bat Shlomo 32.58718195_35.01053736', point_name := 'Bat Shlomo Kkl 3'] 

# Only 1 plot in Eutanim in T0 - why?
reptiles[site %like% 'Eitanim' & campaign == 'T0', .(point_name, SciName, count_individuals), keyby = .(Date, ITime)] # By comparing to the original data file, we can see that all 3 Eitanim plots were surveyed:
reptiles[point_name == 'Eitanim 31.77909156_35.10359697', point_name := 'Eitanim Kkl 2'] 

# Only 2 plots in Eshtaol in T0 - why?
reptiles[site %like% 'Eshtaol' & campaign == 'T0', .(point_name, SciName, count_individuals), keyby = .(Date, ITime)] # By comparing to the original data file, we can see that all 3 Eshtaol plots were surveyed:
reptiles[point_name == 'Eshtaol 31.78378561_35.02056481', point_name := 'Eshtaol Kkl 4'] 
reptiles[point_name == 'Eshtaol 31.78694021_35.02193935', point_name := 'Eshtaol Kkl 3']

# Only 2 plots in Givat Yeshayahu in T0 - why?
reptiles[site %like% 'Yeshayahu' & campaign == 'T0', .(point_name, SciName, count_individuals), keyby = .(Date, ITime)] # By comparing to the original data file, we can see that all 3 Givat Yeshayahu plots were surveyed:
reptiles[point_name == 'Givat Yeshayahu 31.66774825_34.92543564', point_name := 'Givat Yeshayahu 3'] 
reptiles[point_name == 'Givat Yeshayahu 31.66540534_34.91739057', point_name := 'Givat Yeshayahu 2'] 

# Only 2 plots in Kerem Maharal in T0 - why?
reptiles[site %like% 'Maharal' & campaign == 'T0', .(point_name, SciName, count_individuals), keyby = .(Date, ITime)] # By comparing to the original data file, we can see that all 3 Kerem Maharal plots were surveyed:
reptiles[point_name == 'Kerem Maharal 32.61292488_34.96995645', point_name := 'Kerem Maharal Kkl 1'] 
reptiles[point_name == 'Kerem Maharal 32.61228912_34.96368208', point_name := 'Kerem Maharal Kkl 3'] 

# Only 2 plots in Manara in T0 - why?
reptiles[site %like% 'Manara' & campaign == 'T0', .(point_name, SciName, count_individuals), keyby = .(Date, ITime)] # By comparing to the original data file, we can see that all 3 Manara plots were surveyed:
reptiles[point_name == 'Manara 33.17320998_35.5510869', point_name := 'Manara Kkl 2'] 
reptiles[point_name == 'Manara 33.18278817_35.54829586', point_name := 'Manara Kkl 1'] 

# Only 2 plots in Ofer in T0 - why?
reptiles[site %like% 'Ofer' & campaign == 'T0', .(point_name, SciName, count_individuals), keyby = .(Date, ITime)] # By comparing to the original data file, we can see that all 3 Ofer plots were surveyed:
reptiles[point_name == 'Ofer 33.17320998_35.5510869', point_name := 'Ofer Kkl 1'] 
reptiles[point_name == 'Ofer 32.66032073_34.97882237', point_name := 'Ofer Kkl 3'] 

# Only 2 plots in Zuriel in T0 - why?
reptiles[site %like% 'Zuriel' & campaign == 'T0', .(point_name, SciName, count_individuals), keyby = .(Date, ITime)] # By comparing to the original data file, we can see that all 3 Zuriel plots were surveyed:
reptiles[point_name == 'Zuriel 33.013998_35.31735071', point_name := 'Zuriel Kkl 3'] 
reptiles[point_name == 'Zuriel 33.01092878_35.31488161', point_name := 'Zuriel Kkl 2'] 

# 4 plots in Ofer in T1 (2015) - why?
reptiles[site %like% 'Ofer' & campaign == 'T1', .(point_name, SciName, count_individuals), keyby = .(Date, ITime)] # 16.9.2015 = Kerem Maharal; 3.11.2015 = Ofer - but site names were reveresed!
reptiles[site %in% c('Ofer', 'Kerem Maharal') & campaign == 'T1', .(site, point_name, SciName, count_individuals), keyby = .(Date, ITime)]
reptiles[site %in% c('Ofer', 'Kerem Maharal') & Date == as.Date('2015-09-16'), ':=' (site = 'Ofer',
                                                                                     point_name = str_replace(point_name, 'Kerem Maharal', 'Ofer'))]
reptiles[site %in% c('Ofer', 'Kerem Maharal') & Date == as.Date('2015-11-03'), ':=' (site = 'Kerem Maharal',
                                                                                     point_name = str_replace(point_name, 'Ofer', 'Kerem Maharal'))]
reptiles[point_name == 'Kerem Maharal Far 1', point_name := 'Kerem Maharal Kkl Plantings 1']
reptiles[site %in% c('Ofer', 'Kerem Maharal'), .(no.of.plots = uniqueN(point_name)), keyby = .(campaign, unit, site)] # Now all is okay

# This is a zero count survey as per the Fulcrum - use the zero.obs object to include it! 
# reptiles <- unique(rbind(reptiles, data.table(unit = 'Planted Conifer Forests', campaign = 'T1', year = 2015, site = 'Bat Shlomo',
#                                               settlements = 'Far', SciName = NA, heb_name = NA, Occurrence = 0, subunit = 'Carmel',
#                                               count_individuals = 0, point_name = 'Bat Shlomo Far 1',
#                                               point_name = 'Bat Shlomo Far 1 - missing plot', Date = as.Date('2015-07-07'),
#                                               Date.time = as.POSIXct('2015-07-07 09:03', tz = 'Asia/Jerusalem'), ITime = as.ITime('09:03')), fill = T))

# Kerem Maharal T1 (2015) should have 3 plots:
reptiles[site %like% 'Maharal' & campaign == 'T1',.(total.obs = sum(count_individuals)), keyby = .(Date, ITime, point_name)] # 

reptiles <- rbind(reptiles, data.table(unit = 'Planted Conifer Forests', campaign = 'T1', year = 2015, site = 'Kerem Maharal',
                                       settlements = 'Far', SciName = 'Ablepharus rueppellii', heb_name = 'חומט גמד', Occurrence = 1,
                                       subunit = 'Carmel', count_individuals = 7, point_name = 'Kerem Maharal Far 1',
                                       Date = as.Date('2015-11-03'), Comments = 'Missing plot',
                                       Date.time = as.POSIXct('2015-11-03 10:36', tz = 'Asia/Jerusalem'), 
                                       start_Time = as.ITime('10:36'), ITime = as.ITime('10:36')), fill = T)
reptiles <- rbind(reptiles, data.table(unit = 'Planted Conifer Forests', campaign = 'T1', year = 2015, site = 'Kerem Maharal',
                                       settlements = 'Far', SciName = 'Mediodactylus orientalis', heb_name = 'שממית עצים', Occurrence = 1,
                                       subunit = 'Carmel', count_individuals = 3, point_name = 'Kerem Maharal Far 1',
                                       Date = as.Date('2015-11-03'), Comments = 'Missing plot',
                                       start_Time = as.ITime('10:36'), Date.time = as.POSIXct('2015-11-03 10:36', tz = 'Asia/Jerusalem'), ITime = as.ITime('10:36')), fill = T)
reptiles[, survey_ID := paste(campaign, point_name, sep = '_')]

reptiles[point_name == '32.61601959_34.96652201' & campaign == 'T1', .(Date, SciName, count_individuals)]

reptiles[unit %like% 'Forest' & !is.na(SciName), .(total.abnd = sum(count_individuals), total.sp.rich = uniqueN(SciName))]
reptiles[unit %like% 'Forest', .(no.of.surveys = uniqueN(survey_ID)), keyby = .(campaign, year, subunit, site)][no.of.surveys != 3]
# why 4 surveys in Kerem Maharal and 2 in Ramat Hashofet in T1 (2015)?
# We know that Ramat Hashofet 3 was not surveyed in 2015; 
reptiles[site %in% reptiles[unit %like% 'Forest', .(no.of.surveys = uniqueN(survey_ID)), keyby = .(campaign, subunit, site)][no.of.surveys != 3, site],
         .(campaign, site, point_name, Date, SciName, count_individuals)]
# Kerem Maharal Far 1 should be the same as Kerem Maharal Kkl Plantings 1:
reptiles[point_name %in% c('Kerem Maharal Far 1', 'Kerem Maharal Kkl 1', 'Kerem Maharal Kkl Plantings 1'),
         ':=' (point_name = 'Kerem Maharal Kkl Plantings 1', survey_ID = paste(campaign, 'Kerem Maharal Kkl Plantings 1', sep = '_'))]
reptiles[unit %like% 'Forest', .(no.of.surveys = uniqueN(survey_ID)), keyby = .(campaign, year, subunit, site)][no.of.surveys != 3]

# Make sure all survey IDs have the same coordinates (when available):
reptiles[, ':=' (mean.lat = mean(mean.lat, na.rm = T), mean.lon = mean(mean.lon, na.rm =T)), keyby = survey_ID]
reptiles[is.na(mean.lat) | is.na(mean.lon), ':=' (mean.lat = mean(latitude, na.rm = T), mean.lon = mean(longitude, na.rm = T))]
```

```{r diel pattern}
# Calculate a diel pattern via a cosinor model
reptiles[, .(no.of.times = uniqueN(ITime)), keyby = survey_ID][no.of.times > 1] # 72 cases where there is more than one time per survey ID!
reptiles[, ITime := min(ITime, na.rm = T), keyby = survey_ID] # take the earlist time as the survey's start time
reptiles[, .(no.of.times = uniqueN(ITime)), keyby = survey_ID][no.of.times > 1] # Now this is an empty data.table

reptiles[, Date.time := as.POSIXct(paste(Date, ITime, tz = 'Asia/Jerusalem'))] # Create a Date and time object

reptiles[, ':=' (dist.noon = ifelse(as.ITime(ITime) < as.ITime('12:00'), # If the starting hour is before noon...
                                    Date.time %--% as.POSIXct(paste(Date, '12:00:00'), tz = 'Asia/Jerusalem'), # ...then take the distance from today's noon
                                    Date.time %--% as.POSIXct(paste(Date , '12:00:00'), tz = 'Asia/Jerusalem')))] # else, take the distance from tomorrow's noon
reptiles[, .(max(dist.noon, na.rm = T), min(dist.noon, na.rm = T))] # from 22800 seconds (6 hours and 20 minutes) to ~27600 seconds (7 hours and 40 minutes)
reptiles[dist.noon %in% c(min(dist.noon), max(dist.noon)), .(unit, site, Date, time, ITime)]
hist(reptiles[, ITime], breaks = 24)
reptiles[is.na(dist.noon), sort(unique(Date.time))] # No missing distances to noon
reptiles[is.na(dist.noon)] # should be an empty data.table

ggplot(data = reptiles, aes(x = ITime, y = dist.noon)) + geom_point() # This does not seem good yet

reptiles[, ':=' (dist.noon.radians = dist.noon * pi / (24*60*30), # Convert to radians, one harmonic; divide by the number of seconds in half a day
                 dist.noon.radians.2h = 2*dist.noon * pi / (24*60*30))] # same, two harmonics
reptiles[, .(min(dist.noon), min(dist.noon.radians), max(dist.noon), max(dist.noon.radians))]
unique(reptiles[dist.noon == min(dist.noon), .(Date, ITime, dist.noon, dist.noon.radians)]) # 19:40 (latest hour of survey)
unique(reptiles[dist.noon == max(dist.noon), .(Date, ITime, dist.noon, dist.noon.radians)]) # 5:40 (earliest survey Date)
reptiles[, ':=' (sin.dist.noon = sin(dist.noon.radians), cos.dist.noon = cos(dist.noon.radians),
                 sin.dist.noon.2h = sin(dist.noon.radians.2h), cos.dist.noon.2h = cos(dist.noon.radians.2h))] # Calculate the sin and cosine of the distance from June 21st
plot(reptiles$ITime, reptiles$sin.dist.noon) # Sanity check - should be a wave
plot(reptiles$ITime, reptiles$sin.dist.noon.2h) # Sanity check - should be a denser wave
```

```{r factorial predictors}
# subunits
reptiles[, uniqueN(survey_ID), keyby = subunit] # this makes sense, but note that sampling effort is uneven

# campaign
reptiles[, uniqueN(point_name), keyby = .(unit, campaign, year)] #
reptiles <- reptiles[year != 2013] # omit the 2013 pilot data

# settlements
reptiles[!is.na(settlements), .(no.of.plots = uniqueN(point_name)), keyby = .(unit, settlements)] 
reptiles[unit %like% 'Forest', settlements := NA]
# Far or Near settlements is indicated in Coastal Plain Sands (unbalanced) and in Mediterranean-Desert Transition Zone (balanced)

# agriculture
reptiles[!is.na(agriculture), .(no.of.plots = uniqueN(point_name)), keyby = .(unit, agriculture)] 
# Far or Near agriculture is indicated in inland sands (unbalanced)

# dunes
reptiles[!is.na(dunes), .(no.of.plots = uniqueN(point_name)), keyby = .(unit, dunes)] 
# dune type is indicated in inland sands (balanced) and in coastal dunes (unbalanced)

# habitat
reptiles[!is.na(habitat), .(no.of.plots = uniqueN(point_name), .N), keyby = .(unit, habitat)] 
reptiles[habitat %in% c('Agriculture', 'beduin agriculture'), habitat := 'bedouin agriculture']
reptiles[habitat == 'Loess', habitat := 'loess']
reptiles[habitat == 'KKL Plantings', habitat := 'kkl plantings']
reptiles[!is.na(habitat), .(no.of.plots = uniqueN(point_name), .N), keyby = .(unit, habitat)] 
# reptiles[!is.na(habitat), unit := 'Loess Covered Areas in the Northern Negev'] # Only the Loess should have 'habitat' field; all other units with a value in the habitat field are mistakes
reptiles[!is.na(habitat), .(no.of.plots = uniqueN(point_name), .N), keyby = .(unit, habitat)] 

# habitat type is indicated in loess (roughly balanced)

setorder(reptiles, unit, campaign, site, habitat, point_name, Date, ITime) # Make sure the observations are ordered sensibly
reptiles
```

```{r sampling effort}
reptiles[, .(no.of.surveys = uniqueN(survey_ID), no.of.plots = uniqueN(point_name), no.of.sites = uniqueN(site)),
         keyby = .(unit, campaign, year)]
reptiles[, .(no.of.surveys = uniqueN(survey_ID), no.of.plots = uniqueN(point_name), no.of.sites = uniqueN(site)),
         keyby = .(unit, campaign)]
```

```{r date and seasonality}
reptiles[, sort(unique(date))] # Which dates are there in the data base?
reptiles[, .(date = unique(date), Date = unique(as.Date(date, format = '%d/%m/%Y')))] # seems ok
reptiles[is.na(date), .N] # 69 records with no dates
reptiles[is.na(date) & is.na(Date)] # but no records with neither date or Date
reptiles[!is.na(date) & is.na(as.Date(date))] # No dates would be converted to NAs via as.Date
reptiles[, sort(unique(as.Date(date))), keyby = date] # this is clearly wrong
reptiles[is.na(Date), Date := as.Date(date, format = '%d/%m/%Y')]
reptiles[is.na(Date), .N] # now there are no records without dates
reptiles[, sort(unique(Date))] # Which dates are there in the data base?
str(reptiles) # verify that "Date" is indeed defined as a date
reptiles[, .(no.of.dates = uniqueN(Date)), keyby = .(campaign, unit, site, survey_ID)][no.of.dates > 1] # 25 cases in which there is more than one date per survey ID (all from T0)
excessive_dates <- reptiles[, .(no.of.dates = uniqueN(Date)), keyby = .(campaign, unit, site, survey_ID)][no.of.dates > 1]
reptiles[survey_ID %in% excessive_dates$survey_ID, .(Date = unique(Date)), keyby = .(campaign, site, point_name, survey_ID)] # in some cases, these are different plots; in others, the dates are one day apart
reptiles[survey_ID == 'T2_NA', unique(point_name)] # very different plots are lumped here
reptiles[survey_ID == 'T2_NA', survey_ID := paste(campaign, point_name, sep = '_')]
excessive_dates <- reptiles[, .(no.of.dates = uniqueN(Date)), keyby = .(campaign, unit, site, survey_ID)][no.of.dates > 1]
reptiles[survey_ID %in% excessive_dates$survey_ID, .(Date = unique(Date)), keyby = .(campaign, site, point_name, survey_ID)] # now the dates are one day apart
bla <- copy(reptiles) # Back up before changing dates
bla[, Date := min(Date), keyby = survey_ID] # each survey's date will arbitrary gain its earliest date
bla[, sort(unique(Date))] # make sure the dates make sense
bla[survey_ID %in% excessive_dates$survey_ID, .(Date = unique(Date)), keyby = .(campaign, site, point_name, survey_ID)] # now there is only one date per survey
bla[, .(no.of.dates = uniqueN(Date)), keyby = .(campaign, unit, site, survey_ID)][no.of.dates > 1] # no more multiple dates per survey
reptiles <- copy(bla) # return to the original data name
rm(bla) # clean up

reptiles[, .(no.of.records = .N, sp.rich = uniqueN(SciName), first.yr = min(year), last.year = max(year)), keyby = .(unit)] # all records
reptiles[, .(no.of.records = .N, sp.rich = uniqueN(heb_name)), keyby = .(unit)] # Should be the same, but species richness is not
reptiles[, .(first.survey = min(Date), last.survey = max(Date)), keyby = .(unit, campaign)]
# reptiles[is.rare.in.unit == F, .(no.of.records = .N, sp.rich = uniqueN(SciName)), keyby = .(unit)] # without rare species

# Express seasonality as the sine and cosine of the distance in radians from June 21st (longest day of the year)
reptiles[, ':=' (dist.21.June = ifelse(as.integer(as.Date(paste('1970', month(Date), day(Date), sep = '-'))) < 354,
                                     Date - as.Date(paste(year(Date), 6, 21, sep = '-')),
                                     Date - as.Date(paste(year(Date) + 1, 6, 21, sep = '-'))))]
reptiles[, .(max(dist.21.June, na.rm = T), min(dist.21.June, na.rm = T))] # Negative values = all Dates are before June 21st (and after December 21 of the previous year)
reptiles[is.na(dist.21.June), sort(unique(Date))] # No missing distances to June 21st
reptiles[is.na(dist.21.June)] # should be an empty data.table
reptiles[, ':=' (dist.21.June.radians = dist.21.June * pi / 182.5, # Convert to radians, one harmonic
               dist.21.June.radians.2h = 2*dist.21.June * pi / 182.5)] # same, two harmonics
reptiles[, .(min(dist.21.June), min(dist.21.June.radians), max(dist.21.June), max(dist.21.June.radians))]
unique(reptiles[dist.21.June == min(dist.21.June), .(Date, dist.21.June, dist.21.June.radians)]) # March 2dth (earliest survey Date)
unique(reptiles[dist.21.June == max(dist.21.June), .(Date, dist.21.June, dist.21.June.radians)]) # November 25th (latest survey Date)
reptiles[, ':=' (sin.dist.21.June = sin(dist.21.June.radians), cos.dist.21.June = cos(dist.21.June.radians),
               sin.dist.21.June.2h = sin(dist.21.June.radians.2h), cos.dist.21.June.2h = cos(dist.21.June.radians.2h))] # Calculate the sin and cosine of the distance from June 21st
reptiles[is.na(sin.dist.noon) | is.na(sin.dist.21.June), .(unit, Date, site, point_name, ITime)] # Date and time are available, though

# Survey dates and times
reptiles[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(unit, campaign, month(Date))]
write_excel_csv(reptiles[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(unit, campaign, month(Date))],
                '../Analysis/No. of surveys per unit, campaign and calendar month.csv')
write_excel_csv(reptiles[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(unit, month(Date))],
                '../Analysis/No. of surveys per unit and calendar month.csv')
reptiles[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(unit, campaign, round(ITime))]
write_excel_csv(reptiles[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(unit, campaign, round(ITime))],
                '../Analysis/No. of surveys per unit, campaign and rounded hour.csv')
write_excel_csv(reptiles[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(unit, round(ITime))],
                '../Analysis/No. of surveys per unit and rounded hour.csv')
```

```{r Species and their traits}
species.list <- read_excel('../data/Reptile_species_traits.xlsx', sheet = 'to_import') %>% as.data.table()
reptiles[, heb_name := NULL]
reptiles <- merge(reptiles, species.list[, .(SciName, heb_name)], by = 'SciName', all.x = T) # add Hebrew species names
reptiles[is.na(heb_name), sort(unique(SciName))] # 10 species with no Hebrew names
reptiles[is.na(SciName), .N] # 48 records with no species
reptiles[is.na(SciName) & count_individuals > 0, .N] # But none of them have reported any reptiles anyway
reptiles <- rbind(merge(reptiles[!is.na(SciName)], species.list[!is.na(SciName), .(SciName = old_sciname, heb_name)], by = 'SciName', all.x = T),
                  reptiles[is.na(SciName)], fill = T) # Add Hebrew names wherever there are any species names
reptiles[, ':=' (heb_name = ifelse(!is.na(heb_name.x), heb_name.x, heb_name.y), heb_name.x = NULL, heb_name.y = NULL)]
reptiles[is.na(heb_name), sort(unique(SciName))] # 7 more species with no Hebrew names
reptiles[SciName %in% c('Chamaeleo chamaeleon musae', 'Chamaeleo chamaeleon recticrista'),
         ':=' (SciName = 'Chamaeleo chamaeleon', heb_name = 'זיקית')]
reptiles[SciName == 'Stellagama stellio', ':=' (SciName = 'Laudakia vulgaris', heb_name = 'חרדון מצוי')]
reptiles[SciName == 'Xerotyphlops vermicularis', ':=' (SciName = 'Xerotyphlops syriacus', heb_name = 'נחשיל מצוי')]
reptiles[SciName == 'Eirenis rothi', ':=' (SciName = 'Eirenis rothii', heb_name = 'שלוון טלוא-ראש')]
reptiles[SciName == 'Eumeces schneideri', ':=' (SciName = 'Eumeces schneiderii', heb_name = 'חומט מנומר')]
reptiles[SciName == 'Laudakia stellio', ':=' (SciName = 'Laudakia vulgaris', heb_name = 'חרדון מצוי')]
reptiles[is.na(heb_name), sort(unique(SciName))] # No more species with no Hebrew names
reptiles[, .(no.of.Heb_names = uniqueN(heb_name)), keyby = SciName][no.of.Heb_names > 1] # No species with multiple Hebrew names
reptiles[, .(no.of.Sci_names = uniqueN(SciName)), keyby = SciName][no.of.Sci_names > 1] # No species with multiple scientific names
reptiles[!SciName %in% species.list$SciName, unique(SciName)] # species missing in the official species list
reptiles[SciName == 'Acanthodactylus schreiberi', SciName := 'Acanthodactylus boskianus']
reptiles[SciName == 'Eumeces schneideri schneideri', SciName := 'Eumeces schneiderii']
reptiles[SciName == 'Mediodactylus kotschyi', SciName := 'Mediodactylus orientalis']
reptiles[SciName == 'Mesalina guttulata', SciName := 'Mesalina bahaeldini']
reptiles[SciName == 'Rhinotyphlops simoni', SciName := 'Letheobia simoni']
reptiles[SciName == 'Testudo werneri', SciName := 'Testudo kleinmanni']
reptiles[SciName == 'Malpolon monspessulanus', SciName := 'Malpolon insignitus']
reptiles[SciName == 'Trachylepis vittata', SciName := 'Heremites vittatus']
reptiles[!SciName %in% species.list$SciName, unique(SciName)] # No more species missing in the official species list
reptiles[is.na(SciName), sort(unique(heb_name))]
reptiles[is.na(SciName) & !is.na(heb_name)] # All records without a scientific name also have no Hebrew names
reptiles[is.na(SciName), sort(unique(count_individuals))] # Missing scientific names are always zero counts
```

```{r Temperature}
reptiles[is.na(temp_sun) & is.na(temp_shade), .N] # 969 records with no temperature data
reptiles[is.na(temp_sun) & is.na(temp_shade), .N, keyby = .(unit)] # fairly evenly spread
surveys.with.sun_temp <- reptiles[!is.na(temp_sun), .(survey_ID = unique(survey_ID)), keyby = .(campaign, unit)]
reptiles[survey_ID %in% surveys.with.sun_temp$survey_ID, uniqueN(survey_ID)] # 431 surveys with sun temperature
reptiles[!survey_ID %in% surveys.with.sun_temp$survey_ID, uniqueN(survey_ID)] # 300 surveys without sun temperature
reptiles[!survey_ID %in% surveys.with.sun_temp$survey_ID, uniqueN(survey_ID), keyby = unit] # surveys without temperature data are prevalent
# Alas, temperature cannot be used as a predictor due to many surveys that lack it
quantile(reptiles[, temp_shade], na.rm = T) # from 14 to 42.5 degrees
quantile(reptiles[, temp_sun], na.rm = T) # 511.0 degrees make no sense!
reptiles[temp_sun == 511, temp_sun := 51.1] # 51.1 is still an extreme temperature, but it makes more sense

reptiles[, ':=' (scaled.temp.shade = scale(temp_shade), scaled.temp.sun = scale(temp_sun))] # Scale predictors
GGally::ggpairs(reptiles[, .(scaled.temp.shade, scaled.temp.sun)]) 
# obviously, the two temperature measures are highly and significantly correlated (0.703)
```

```{r Number of stones}
reptiles[, sort(unique(stones_flipped))] # From zero to 240 stones
reptiles[, uniqueN(stones_flipped), keyby = survey_ID][V1 != 1] # Sanity check: empty data.table = only one number of stones flipped per survey
reptiles[(unit %like% 'Coast' | unit %like% 'Sand'), sort(unique(stones_flipped)), keyby = survey_ID][is.na(V1)]
reptiles[!(unit %like% 'Coast' | unit %like% 'Sand'), sort(unique(stones_flipped)), keyby = survey_ID]
reptiles[!(unit %like% 'Coast' | unit %like% 'Sand'), sort(unique(stones_flipped)), keyby = survey_ID][is.na(V1)] # no missing numbers of stones flipped
bla <- merge(reptiles, reptiles[!is.na(stones_flipped), sort(unique(stones_flipped)), keyby = survey_ID], by = 'survey_ID', all.x = T)
bla[V1 != stones_flipped] # sanity check
bla[stones_flipped != V1]
bla[!(unit %like% 'Sand' | unit %like% 'Coast'), .N, keyby = .(stones.flipped.known = !survey_ID %in% bla[is.na(V1), unique(survey_ID)])]
# only 598 surveys have information about the number of stones flipped (580 surveys have no such info)

hist(reptiles[!(unit %like% 'Coast' | unit %like% 'Sand'), sort(unique(stones_flipped)), keyby = survey_ID][, V1]) # Peak at 50-100 stones; about 30 surveys with fewer than 30 stones
reptiles[!(unit %like% 'Coast' | unit %like% 'Sand'), sort(unique(stones_flipped)), keyby = survey_ID][V1 < 30, .N]
```

```{r Abundance corrections}
# Indirect observations abundance should be set to 1

# convert all "tracks" observations to a single observation per plot-year-species combination,
# with an individual count of 1
# first reduce multiple track observation of the same species from the same year-plot to a
# single observation
reptiles[activity=="tracks",`:=`(track_obs_id=seq_len(.N),grp_id = .GRP),by=.(survey_ID,SciName)]
reptiles.backup <- copy(reptiles) # Back up the data.table before removing "excessive" observations in field signs of species' presence
reptiles <- reptiles[track_obs_id==1 | is.na(track_obs_id)]

# now convert count of individuals to 1 in all observations of tracks
reptiles[track_obs_id==1,count_individuals:=1]

# convert all "eggs" observations to a single observation per plot-year-species combination,
# with an individual count of 1
# first reduce multiple observation of the same species from the same year-plot to a
# single observation
reptiles[activity=="eggs",`:=`(track_obs_id=seq_len(.N),grp_id = .GRP),by=.(survey_ID,SciName)]
reptiles <- reptiles[track_obs_id==1 | is.na(track_obs_id)]

# now convert count of individuals to 1 in all observations
reptiles[track_obs_id==1,count_individuals:=1]

# convert all "eggshell" observations to a single observation per plot-year-species combination,
# with an individual count of 1
# first reduce multiple observation of the same species from the same year-plot to a
# single observation
reptiles[activity=="eggshell",`:=`(track_obs_id=seq_len(.N),grp_id = .GRP),by=.(survey_ID,SciName)]
reptiles <- reptiles[track_obs_id==1 | is.na(track_obs_id)]

# now convert count of individuals to 1 in all observations
reptiles[track_obs_id==1,count_individuals:=1]

# Observations in over 10 individuals should be set to 1
reptiles[count_individuals > 9, .N] # 3 such records
reptiles[count_individuals > 9, count_individuals := 1]
```

```{r chr to fct}
# convert all character vectors to factors
changeCols <- colnames(reptiles)[which(as.data.table(as.vector(reptiles[,lapply(.SD, class)]))[1,]=="character")]
reptiles[,(changeCols):= lapply(.SD, as.factor), .SDcols = changeCols]
unit_names <- sort(unique(reptiles$unit))
```

```{r wide format}
# Convert to wide format (cast):
str(reptiles)
# Define the left hand side (LHS) of the casting function (i.e. the variables defining the survey event itself rather than species found in the survey = the identity variables):
LHS <- c('unit', 'year','campaign', 'subunit', 'site', 'point_name','survey_ID', 'Date', 'sin.dist.21.June','cos.dist.21.June',
         'sin.dist.noon','cos.dist.noon','settlements','agriculture','dunes','habitat','mean.lon','mean.lat')
# Cast the data according to the left hand side (the identity variables):
rept_cast <- dcast.data.table(reptiles,as.formula(paste(paste(LHS, collapse = "+"), "~ SciName")),
                               fun.aggregate = sum, value.var = "count_individuals")
str(rept_cast)
names(rept_cast)
rept_cast.abnd <- rept_cast[, 23:length(rept_cast)] # Subset only the species' fields as the response variables
rept_cast.abnd <- as.matrix(rept_cast.abnd) # Convert to matrix for gllvm

rept.env <- as.data.table(rept_cast[, 1:20]) # subset the environmental predictors of the reptiles data 
str(rept.env)

write_excel_csv(rept_cast, file = '../output/Basic matrix - plots-campaign rows, species columns - individual counts.csv')
```

## Define rare species
Although we decided not to exclude rare reptile species from the analyses, I add this here for completeness:

```{r rare species}
# setwd('C:/Users/User/OneDrive - Tel-Aviv University/Maarag/State of Nature Report/2023/Reptiles') # Change this to your file path

### 5. Define rare species (to be excluded from certain analyses)----
# cutoff for rare species - minimum number of plots in which the species was observed. The key is two plots per campaign containing 30 plots, rounded to the nearest integer.
# an additional cutoff is a minimum of 10 individuals.
# plot numbers are as follows:
reptiles[, .(no.of.plots = uniqueN(point_name), no.of.surveys = uniqueN(survey_ID)), keyby = unit]
min_plots_cutoff <- reptiles[,.(campaign_num=uniqueN(campaign)), by=unit][order(unit)][,plots_per_camp:= reptiles[,
          uniqueN(conc_lat_lon), keyby = unit][, V1]][,cutoff:=round(campaign_num*plots_per_camp/30)][cutoff<10,cutoff:=10]
# First condition: Less than one occurrence per campaign with 30 plots:

reptiles[, uniqueN(conc_lat_lon), keyby = .(unit, campaign)] # There are more than 9 plots per campaign - we need to adjust
reptiles[, .(no.of.plots = uniqueN(conc_lat_lon)), keyby = .(unit, campaign)][, .(adjusted.min.ind = round(no.of.plots/30*2)), keyby = .(unit,campaign)] # T1's minimum no. of individuals should be 1 and not two

rare.species1 <- reptiles[, .(no.of.occurrences = sum(Occurrence)), keyby = .(unit, campaign, Species = str_replace_all(SciName, '_', ' '))][no.of.occurrences < 2,
                                                                                                                                       .(Species = sort(unique(as.character(Species))), condition1 = 'Fewer than two occurrence per campaign'), keyby = unit]
rare.species1

# Second condition: fewer than 10 individuals overall:
species.freq <- reptiles[count_individuals > 0, .(total.no.of.ind = sum(count_individuals)),
                     keyby = .(unit, heb_name, SciName)] # Species frequencies; originally, 37 species
species.freq #  Species frequencies; 
species.freq[, uniqueN(SciName)] # originally, 52 species
rare.species2 <- species.freq[total.no.of.ind < 10, .(Species = SciName, condition2 = 'Fewer than 10 individuals overall'), keyby = unit]
rare.species2

# Create a species list from both conditions:
rare.species <- merge(rare.species1, rare.species2, by = c('unit', 'Species'), all = T) # combine species lists
rare.species <- merge(rare.species, species.list[, .(Species = unique(SciName)), keyby = heb_name], by = 'Species', all.x = T) # Add Hebrew names
setcolorder(rare.species, c('unit','Species', 'heb_name')); setorder(rare.species, unit, Species, heb_name)
rare.species
rare.species[, .(no.of.rare.spp = uniqueN(Species)), keyby = unit] # no fewer than 19 rare species in the semi desert
write_excel_csv(rare.species, file = '../output/Rare species to be removed from certrain analyses.csv')
rm(rare.species1, rare.species2) # clean up

# Indicate rare species per unit
reptiles <- merge(reptiles, rare.species[, .(SciName = Species, unit, is.rare.in.unit = T)], by = c('unit', 'SciName'), all.x = T)
reptiles[is.na(is.rare.in.unit), is.rare.in.unit := F]
reptiles[survey_ID %in% reptiles[is.rare.in.unit == F, unique(survey_ID)], unique(survey_ID)]
reptiles[, .(no.of.surveys = uniqueN(survey_ID)), keyby = is.rare.in.unit] # 674 surveys with at least one non-rare species
reptiles[count_individuals > 0, .(no.of.spp = uniqueN(SciName)), keyby = .(unit, is.rare.in.unit)] # sometimes there are more rare species than non-rare ones
setorder(reptiles, unit, campaign, subunit, site, conc_lat_lon, survey_ID)
```
Note the large number of rare species out of the total.

Age of the reptiles:
```{r age}
age.dist  <- reptiles[observation_type == 'direct', .(total.individuals = sum(count_individuals)), keyby = .(survey_ID, age)]

ggplot(data = age.dist, aes(color = age, x = age, y = total.individuals)) + geom_violin()

ggplot(data = reptiles[count_individuals > 0], aes(color = age, x = age, y = count_individuals)) + geom_jitter(height = 0) + geom_boxplot() 

reptiles[count_individuals > 2, .N, keyby = age]
```

## Alpha diveristy
Generate a table of alpha diversity: species richness, total reptile abundance and geometric mean abundance per survey (defined here as a unique plot-campaign combination).

```{r alpha diversity}
# Species richness
sp.richness.data <- reptiles[count_individuals > 0, .(species.richness = uniqueN(SciName)), keyby = LHS]
sp.richness.data[, uniqueN(survey_ID)] # 630 surveys over all
sp.richness.data[, .N, keyby = survey_ID][N > 1] # 2 cases of more than one row per survey
sp.richness.data[survey_ID %in% sp.richness.data[, .N, keyby = survey_ID][N > 1, survey_ID]]
reptiles[survey_ID %in% sp.richness.data[, .N, keyby = survey_ID][N > 1, survey_ID], .SD, .SDcols = LHS] # Mean coordinates are NA in two rows in Kerem Maharal Kkl Plantings 1
sp.richness.data[, min(species.richness)] # no zero species richness plots here though
sp.richness.data <- rbind(sp.richness.data, reptiles[count_individuals == 0, .(species.richness = 0), keyby = LHS]) # add all the zero species richness surveys
sp.richness.data[, uniqueN(survey_ID)] # Now there are 697 surveys

# Total plot abundance, with rare species
total.abnd <- reptiles[, .(total.abundance = sum(count_individuals)), keyby = LHS]
total.abnd[, uniqueN(survey_ID)] # 697 surveys over all, same as with the species richness

# Total plot abundance, without rare species
total.abnd.no.rare <- reptiles[is.rare.in.unit == F | count_individuals == 0, .(total.abundance = sum(count_individuals)), keyby = LHS]
total.abnd.no.rare[, uniqueN(survey_ID)] # 645 surveys including only non-rare species
reptiles[is.rare.in.unit == F, .(total.abundance = sum(count_individuals)), keyby = LHS]

# geometric mean abundance, without rare species - THIS IS IRRELEVANT AS WE DECIDED NOT TO CALCULATE GMA
rept.total.abnd.per.sp <- reptiles[is.rare.in.unit == F, .(Total.sp.abnd = sum(count_individuals, na.rm = T)),
                                                  keyby = c(LHS, 'SciName')]
rept.total.abnd.per.sp[!is.na(Total.sp.abnd) & Total.sp.abnd > 0, uniqueN(survey_ID)] # 578 surveys including non-rare species
gma.no.rare <- rept.total.abnd.per.sp[, .(geom.mean.abundance = exp(mean(log(Total.sp.abnd)))), keyby = c(LHS)]
gma.no.rare[, uniqueN(survey_ID)] # 640 surveys including non-rare species

reptiles[, .(total.count = sum(count_individuals)), keyby = .(unit, is.rare.in.unit)] # Note that rare species consist a considerable portion of the data

# Define a table of all three alpha diversity indices:
alpha.div <- merge(sp.richness.data, total.abnd, by = LHS, all = T) # merge species richness and total plot abundance (including rare species)
alpha.div <- merge(alpha.div, gma.no.rare, by = LHS, all = T) # add also geometric mean abundance (omitting rare species)
# alpha.div <- merge(alpha.div, reptiles[, .(year = unique(year)), keyby = .(unit, campaign)], by = c('unit', 'campaign'), all.x = T) # add the first year of the campaign
alpha.div[, ':=' (year.count = year - min(year), year.fct = as.factor(year)), keyby = unit]
alpha.div[, .(first.year = min(year), first.year.count = min(year.count)), keyby = unit]

alpha.div[is.na(species.richness), .N] # no cases of missing species richness
alpha.div[is.na(total.abundance), .N] # no  cases of missing total abundance
alpha.div[is.na(geom.mean.abundance), .N] # 53 cases of missing geometric mean abundance, though!
alpha.div[is.na(geom.mean.abundance) & !survey_ID %in% reptiles[is.rare.in.unit == T, survey_ID], ] # all of them in surveys where only rare species were found
reptiles[survey_ID %in% alpha.div[is.na(geom.mean.abundance), survey_ID] & is.rare.in.unit == F,
         .(survey_ID, SciName, count_individuals, is.rare.in.unit)]
rept.total.abnd.per.sp[survey_ID %in% alpha.div[is.na(geom.mean.abundance), survey_ID],
         .(survey_ID, SciName, Total.sp.abnd)] # 
gma.no.rare[is.na(geom.mean.abundance), unique(survey_ID)]

alpha.div[, .(no.of.surveys = uniqueN(survey_ID))] # 697 surveys
alpha.div[, .(no.of.surveys = uniqueN(survey_ID)), keyby = unit] # 5 units

str(alpha.div)
GGally::ggpairs(alpha.div[, .(unit, year.count, sin.dist.21.June, species.richness, total.abundance)], progress = F) # species richness and total abundance are highly correlated (0.82)
```

# Coastal Plain Dunes
Species richness data exploration:
```{r Coastal Plain Dunes}
reptiles[unit %like% 'Coast' & !is.na(SciName), .(total.abnd = sum(count_individuals), total.sp.rich = uniqueN(SciName))]
reptiles[unit %like% 'Coast', .(no.of.surveys = uniqueN(survey_ID)), keyby = .(year, campaign, site, dunes, settlements)]

coast <- alpha.div[unit == 'Coastal Plain Sands'] # subset the coast plain sands
str(coast)
coast[is.na(settlements) | is.na(dunes)] # no missing variables

GGally::ggpairs(coast[, .(dunes, settlements, year.count, sin.dist.21.June, cos.dist.21.June, # we do not include the time of day in the sands protocol as it includes both morning and afternoon survey in the same plot
                           species.richness, total.abundance)], progress = F)

# Dot plots
coast.sp.rich.dotplot <- ggplot(data = coast, aes(x = species.richness, y = site)) +
  geom_point(aes(color = dunes, shape = settlements)) +  geom_line(aes(group = site)) +
  facet_grid(campaign ~ ., scales = 'free_y') + labs(title = 'Reptile Species Richness in the Coastal Sands', y = 'Site', x = 'Species Richness', color = 'Dune Type', shape = 'Proximity to settlements') + 
  scale_color_manual(values = okabe) + scale_x_continuous(limits = c(0, coast[, max(species.richness) + 1]),
                                                          breaks = seq(0, coast[, max(species.richness) + 1], by = 2)) +
  theme_bw() + theme(legend.position = 'bottom',
                     plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
coast.sp.rich.dotplot
ggsave('../output/Reptile species richness in the coastal sands - dotplot.png', plot = coast.sp.rich.dotplot)

# The relevant predictors are distance to settlement, dunes, and temporal trend
# Plot species richness
ggplot(data = coast, aes(x = dunes, color = settlements, y = species.richness)) + geom_boxplot() + 
  geom_jitter(height = 0, width = 0.3) +  facet_wrap(. ~ year) + theme_bw()
# There are no semi-shifting dunes in near plots - this might be problematic with the model; 2014-2015 seem lower than the later years
```
# Inland sands
Next unit: the inland sands. Some exploration first:
```{r}
reptiles[unit %like% 'Inland' & !is.na(SciName), .(total.abnd = sum(count_individuals), total.sp.rich = uniqueN(SciName))] # 594 reptiles from 17 species

alpha.div[, sort(unique(unit))]
inland.sands <- alpha.div[unit == 'Inland Sands'] # subset the inland sands
str(inland.sands)
inland.sands[is.na(agriculture) | is.na(dunes)] # no missing variables

inland.sands[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(campaign, year, site, agriculture, dunes)] # Always 3 surveys per site-agri-dunes

# Dot plots
Inner.sands.sp.rich.dotplot <- ggplot(data = inland.sands, aes(x = species.richness, y = site)) +
  geom_point(aes(color = dunes, shape = agriculture)) +  geom_line(aes(group = site)) +
  facet_grid(campaign ~ .) + labs(title = 'Reptile Species Richness in the Inner Sands', y = 'Site', x = 'Species Richness', color = 'Dune Type',
                                  shape = 'Proximity to agriculture') + 
  scale_color_manual(values = okabe) + scale_x_continuous(limits = c(0, inland.sands[, max(species.richness) + 1]),
                                                          breaks = seq(0, inland.sands[, max(species.richness) + 1], by = 2)) +
  theme_bw() + theme(legend.position = 'bottom',
                     plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
Inner.sands.sp.rich.dotplot
ggsave('../output/Reptile species richness in the Inner sands - dotplot.png', plot = Inner.sands.sp.rich.dotplot)

Inner.sands.abnd.dotplot <- ggplot(data = inland.sands, aes(x = total.abundance, y = site)) +
  geom_point(aes(color = dunes, shape = agriculture)) +  geom_line(aes(group = site)) +
  facet_grid(campaign ~ .) + labs(title = 'Reptile Total Abundance in the Inner Sands', y = 'Site', x = 'Total Abundance', color = 'Dune Type',
                                  shape = 'Proximity to agriculture') + 
  scale_color_manual(values = okabe) + scale_x_continuous(limits = c(0, inland.sands[, max(total.abundance) + 1]),
                                                          breaks = seq(0, inland.sands[, max(total.abundance) + 1], by = 2)) +
  theme_bw() + theme(legend.position = 'bottom',
                     plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
Inner.sands.abnd.dotplot
ggsave('../output/Reptile Total Abundance in the Inner sands - dotplot.png', plot = Inner.sands.abnd.dotplot)
```
## Inland Sands: Calculate distance to the nearest agricultural plot
First, let's find out where are the agricultural plots:
```{r land use legend}
land.use.legend
```
It seems that the agriculture land uses are coded as 12, 41 and 42, so let's subset those:

```{r create agriculture raster}
agri.rast <- subst(land.use, c(12, 41, 42), 1, others = NA)
plot(agri.rast) # Seems ok
```
Calculate a raster of distance to nearest agricultural cell:
```{r calculate distance to agriculture}
agri.dist <- distance(agri.rast)
plot(agri.dist) # This is more or less reasonable
agri.dist
```
Find the coordinates of each plot
```{r coordinates per plot}
inland.sands.plots <- inland.sands[, .(lon = mean(mean.lon), lat = mean(mean.lat)), keyby = .(agriculture, point_name)] # Find the unique coordinates per plot
inland.sands.plots[, .N, keyby = point_name][N > 1] # sanity check: Should yield an empty data.table
inland.sands.plots <- st_as_sf(inland.sands.plots, coords = c("lon", "lat"), crs = 4326, remove = F) %>% st_transform(crs = 2039) # Convert to sf and reproject as Israel Transeverse Meractor
as.data.table(inland.sands.plots)
```
Now let's extract the distances of each plot to the nearest agricultural cell:
```{r distance to agriculture per plot}
inland.sands.plots <- as.data.table(cbind(inland.sands.plots, extract(agri.dist, vect(inland.sands.plots))))
inland.sands.plots # Seems reasonable
```
Summarize and export the results:
```{r export distance per plot}
inland.sands.plots[, .(mean.dist.to.agr = mean(LC_Madad_MigvanB_21v1), min.dist.to.agr = min(LC_Madad_MigvanB_21v1), max.dist.to.agr = max(LC_Madad_MigvanB_21v1), N = uniqueN(point_name)), keyby = agriculture]
write_excel_csv(inland.sands.plots, "../output/Inland sands reptiles - distances to agriculture per plot.csv")
write_excel_csv(inland.sands.plots[, .(mean.dist.to.agr = mean(LC_Madad_MigvanB_21v1), min.dist.to.agr = min(LC_Madad_MigvanB_21v1), max.dist.to.agr = max(LC_Madad_MigvanB_21v1), no.of.plots = uniqueN(point_name)), keyby = agriculture], "../output/Inland sands reptiles - distances to agriculture summary statistics.csv")
```

# Loess
Some data exploration:
```{r data exploration}
reptiles[unit %like% 'Loess' & !is.na(SciName), .(total.abnd = sum(count_individuals), total.sp.rich = uniqueN(SciName))]

## Loess species richness----
loess <- alpha.div[unit == 'Loess Covered Areas in the Northern Negev']
loess[campaign == 'T0', ':=' (year = 2014, year.fct = as.factor(2014))]

str(loess)
loess[is.na(habitat)] # no missing variables
loess[, sort(unique(year)), keyby = campaign] # 2014-2020 every 2 years
loess[, .(no.of.sites = uniqueN(site)), keyby = .(campaign, year)]
loess[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(campaign, year, site)]
loess[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(campaign, year, site, habitat)]

# The relevant predictors are habitat and temporal trend

# Dot plots
loess.sp.rich.dotplot <- ggplot(data = loess, aes(x = species.richness, y = site)) +
  geom_point(aes(color = habitat)) +  geom_line(aes(group = site)) +
  facet_grid(campaign ~ .) + labs(title = 'Reptile Species Richness in the Loess', y = 'Site', x = 'Species Richness', color = 'Habitat') + 
  scale_color_manual(values = okabe) + scale_x_continuous(limits = c(0, loess[, max(species.richness)]),
                                                          breaks = seq(0, loess[, max(species.richness)], by = 2)) +
  theme_bw() + theme(legend.position = 'bottom',
                     plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
loess.sp.rich.dotplot
ggsave('../output/Reptile species richness in the Loess - dotplot.png', plot = loess.sp.rich.dotplot)

loess.abnd.dotplot <- ggplot(data = loess, aes(x = total.abundance, y = site)) +
  geom_point(aes(color = habitat)) +  geom_line(aes(group = site)) +
  facet_grid(campaign ~ .) + labs(title = 'Reptile Total Abundance in the Loess', y = 'Site', x = 'Total Abundance', color = 'Habitat') + 
  scale_color_manual(values = okabe) + scale_x_continuous(limits = c(0, loess[, max(total.abundance) + 1]),
                                                          breaks = seq(0, loess[, max(total.abundance) + 1], by = 2)) +
  theme_bw() + theme(legend.position = 'bottom',
                     plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
loess.abnd.dotplot
ggsave('../output/Reptile Total Abundance in the Loess - dotplot.png', plot = loess.abnd.dotplot)
```

## Planted Conifer Forest
We want to calculate the distance to nearest army base or settlement. For that, we need to create a unified object of both settlements and army bases. To do that, we need to use the function `rbind` on these sf objects, if they have the same columns. First, let's see what columns (attributes) each sf object has:
```{r}
str(army.bases)
str(settlements)
```
Unite the settlements and army base objects before calculating the distance to nearest army base or settlement:
```{r}
army.bases <- st_transform(army.bases, crs = st_crs(settlements)) # Make sure the sf object share a coordinate reference system
army.bases <- as.data.table(army.bases)[, .(SETL_NAME = Name, type = "Security Forces Base", geometry)] %>% st_as_sf()
settlements <- as.data.table(settlements)[, .(SETL_NAME, type = "Settlement", geometry)] %>% st_as_sf()
ggplot() + geom_sf(data = army.bases, color = "red") + geom_sf(data = settlements, color = "lightblue")
```
Rasterize the army bases:
```{r}
base.rast <- fasterize::fasterize(army.bases, raster = raster(land.use), field = NULL)
plot(base.rast, main = "Raster of army bases")
```
Rasterize the settlements:
```{r}
sett.rast <- fasterize::fasterize(settlements, raster = raster(land.use), field = NULL)
plot(sett.rast, main = "Raster of settlements")
```
Combine the army bases and settlements rasters:
```{r}
sett.base.rast <- mosaic(rast(sett.rast), rast(base.rast))
plot(sett.base.rast, main = "Raster of settlements and army bases")
```
Distance of plots to nearest settlement or army base:
```{r}
sett.dist <- distance(sett.base.rast)
plot(sett.dist) # This is more or less reasonable
sett.dist
writeRaster(sett.dist, "../output/Raster of distances to the nearest settlement or army base.tif", overwrite = T)
```
Find the coordinates of each plot
```{r}
Forest.plots <- reptiles[unit %like% "Forest" & !is.na(latitude) & !is.na(longitude), .(latitude = mean(latitude), longitude = mean(longitude)), keyby = .(point_name)] # Find the unique coordinates per plot
Forest.plots[, .N, keyby = point_name][N > 1] # sanity check: Should yield an empty data.table
Forest.plots <- st_as_sf(Forest.plots, coords = c("longitude", "latitude"), crs = 4326, remove = F) %>% st_transform(crs = 2039) # Convert to sf and reproject as Israel Transeverse Meractor
as.data.table(Forest.plots)
reptiles[unit %like% "Forest" & !point_name %in% Forest.plots$point_name, unique(point_name)]
```
Now let's extract the distances of each plot to the nearest settlement or army base cell:
```{r}
Forest.plots <- as.data.table(cbind(Forest.plots, extract(sett.dist, vect(Forest.plots))))
Forest.plots # Seems reasonable
```
Summarize and export the results:
```{r}
Forest.plots[, .(mean.dist.to.sett = mean(layer), min.dist.to.sett = min(layer), max.dist.to.sett = max(layer), N = uniqueN(point_name))]
write_excel_csv(Forest.plots, "../output/Forest reptiles - distances to settlement or army base per plot.csv")
write_excel_csv(Forest.plots[, .(mean.dist.to.sett = mean(layer), min.dist.to.sett = min(layer), max.dist.to.sett = max(layer), no.of.plots = uniqueN(point_name))], "../output/Forest reptiles - distances to settlement or army base summary statistics.csv")
```

Data exploration:

```{r}
### Forest----
reptiles[unit %like% 'Forest' & !is.na(SciName), .(total.abnd = sum(count_individuals), total.sp.rich = uniqueN(SciName))]
reptiles[unit %like% 'Forest', unique(campaign), keyby = year]

## Forest species richness----
alpha.div[, sort(unique(unit))]
Forest <- alpha.div[unit == 'Planted Conifer Forests']
str(Forest)
Forest[is.na(year) | is.na(subunit)] # no missing variables

Forest[, sort(unique(subunit))] # subunit are now sorted alphabetically
Forest[, subunit := fct_relevel(subunit, "Judean Highlands", "Carmel", "Galilee")] # Reorder the Forest subunit from south to north
Forest[, sort(unique(subunit))] # subunit are now sorted alphabetically

Forest[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(campaign, year, subunit, site)][no.of.surveys != 3] # Only Ramat Hashofet missed a survey (in 2015)
Forest[, .(no.of.surveys = uniqueN(survey_ID)), keyby = .(campaign)][no.of.surveys != 45] # T1 missed one survey (Ramat HaShofet, as we noted)
reptiles[unit %like% 'Forest' & campaign == 'T0', .(plot = unique(point_name)), keyby = .(subunit, site, start_Time)]
# Meron and Ramat HaShofet are recorded in the original Excel file but not here!

# Dot plots
Forest.sp.rich.dotplot <- ggplot(data = Forest, aes(x = species.richness, y = site, color = subunit)) +
  geom_point() +  geom_line(aes(group = site)) +
  facet_grid(campaign ~ .) + labs(title = 'Reptile Species Richness in the Forest', y = 'Site', x = 'Species Richness') + 
  scale_color_manual(values = okabe) + scale_x_continuous(limits = c(0, Forest[, max(species.richness)]),
                                                          breaks = seq(0, Forest[, max(species.richness)], by = 1)) +
  theme_bw() + theme(legend.position = 'bottom',
                     plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
Forest.sp.rich.dotplot
ggsave('../output/Reptile species richness in the Forest - dotplot.png', plot = Forest.sp.rich.dotplot, scale = 1.25)

Forest.abnd.dotplot <- ggplot(data = Forest, aes(x = total.abundance, y = site, color = subunit)) +
  geom_point(aes(color = subunit)) +  geom_line(aes(group = site, color = subunit)) +
  facet_grid(campaign ~ .) + labs(title = 'Reptile Total Abundance in the Forest', y = 'Site', x = 'Total Abundance') + 
  scale_color_manual(values = okabe) + scale_x_continuous(limits = c(0, Forest[, max(total.abundance) + 1]),
                                                          breaks = seq(0, Forest[, max(total.abundance) + 1], by = 2)) +
  theme_bw() + theme(legend.position = 'bottom',
                     plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
Forest.abnd.dotplot
ggsave('../output/Reptile Total Abundance in the Forest - dotplot.png', plot = Forest.abnd.dotplot, scale = 1.25)

# The relevant predictor is the subunit and the temporal trend
```
## Semi-desert

Data exploration first:

```{r}
### Mediterranean-Desert Transition Zone (Semi desert, Sfar HaMidbar)----
## semi-desert species richness----
reptiles[unit %like% 'Transition', .(total.abnd = sum(count_individuals), total.sp.rich = uniqueN(SciName))]
reptiles[unit %like% 'Transition' & !is.na(SciName), .(total.abnd = sum(count_individuals), total.sp.rich = uniqueN(SciName))]
reptiles[unit %like% 'Transition', sort(unique(year))]

sfar <- alpha.div[unit == 'Mediterranean-Desert Transition Zone']

str(sfar)
sfar[is.na(settlements) | is.na(year)] # no missing variables

# The relevant predictors are settlements and temporal trend

# Dot plots
sfar.sp.rich.dotplot <- ggplot(data = sfar, aes(x = species.richness, y = site, color = settlements, 
                                                label = str_sub(point_name, start = 1, end = 20))) +
  geom_point() +  geom_line(aes(group = site)) + # ggrepel::geom_text_repel() +
  facet_grid(campaign ~ .) + labs(title = 'Reptile Species Richness in the sfar', y = 'Site', x = 'Species Richness',
                                  color = 'Proximity to settlements') + 
  scale_color_manual(values = okabe) + scale_x_continuous(limits = c(0, sfar[, max(species.richness)]),
                                                          breaks = seq(0, sfar[, max(species.richness)], by = 1)) +
  theme_bw() + theme(legend.position = 'bottom',
                     plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
sfar.sp.rich.dotplot
ggsave('../output/Reptile species richness in the sfar - dotplot.png', plot = sfar.sp.rich.dotplot, scale = 1.25)

sfar.abnd.dotplot <- ggplot(data = sfar, aes(x = total.abundance, y = site, color = settlements,
                                             label = str_sub(point_name, start = 1, end = 20))) +
  geom_point() +  geom_line(aes(group = site)) + # ggrepel::geom_text_repel() +
  facet_grid(campaign ~ .) + labs(title = 'Reptile Total Abundance in the sfar', y = 'Site', x = 'Total Abundance') + 
  scale_color_manual(values = okabe) + scale_x_continuous(limits = c(0, sfar[, max(total.abundance) + 1]),
                                                          breaks = seq(0, sfar[, max(total.abundance) + 1], by = 2)) +
  theme_bw() + theme(legend.position = 'bottom',
                     plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
sfar.abnd.dotplot
ggsave('../output/Reptile Total Abundance in the sfar - dotplot.png', plot = sfar.abnd.dotplot, scale = 1.25)

# Plot species richness
ggplot(data = sfar, aes(x = settlements, color = settlements, y = species.richness)) + geom_boxplot() + 
  geom_jitter(height = 0, width = 0.3) + facet_wrap(. ~ year) + theme_bw()
```

## Export the wrangled data base:
```{r export wrangled data}
str(reptiles)
setorder(reptiles, unit, campaign, year, site, settlements, agriculture, habitat, dunes, Date, ITime, mean.lat, conc_lat_lon, SciName,
         heb_name) # Make sure the data are ordered reasonably
setcolorder(reptiles, c('unit', 'campaign', 'year', 'site', 'point_name', 'mean.lat', 'mean.lon','settlements', 'agriculture', 'habitat', 'dunes', 'Date',
                        'ITime', 'SciName', 'heb_name', 'count_individuals')) # Order the columns reasonably
write_excel_csv(reptiles, '../data/processed/wrangled reptile data T0-T4.csv')
write_excel_csv(reptiles[unit %like% "Plain"], '../data/processed/wrangled reptile data T0-T4 - Coastal Plain Dunes 18.7.24.csv')
save(reptiles, coast, inland.sands, Forest, sfar, file = '../data/processed/wrangled reptile data T0-T4.Rdata')
saveRDS(reptiles, file = "../data/processed/wrangled_reptile_data_T0-T4.rds")
saveRDS(inland.sands, file = "../data/processed/wrangled_reptile_inland_sands_data_T0-T4.rds")

```

